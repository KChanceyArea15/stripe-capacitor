{"version":3,"file":"definitions.js","sourceRoot":"","sources":["../../src/definitions.ts"],"names":[],"mappings":"AA6FA,cAAc,eAAe,CAAC;AAC9B,cAAc,eAAe,CAAC","sourcesContent":["import type { PluginListenerHandle } from '@capacitor/core';\r\n\r\nimport type { TerminalEventsEnum } from './events.enum';\r\nimport type {\r\n  TerminalConnectTypes,\r\n  UpdateTimeEstimate,\r\n  SimulateReaderUpdate,\r\n  SimulatedCardType,\r\n  BatteryStatus,\r\n  ReaderEvent,\r\n  ReaderDisplayMessage,\r\n  ReaderInputOption,\r\n  PaymentStatus,\r\n  DisconnectReason,\r\n  ConnectionStatus,\r\n  NetworkStatus,\r\n  LocationStatus,\r\n  DeviceType,\r\n} from './stripe.enum';\r\n\r\nexport type ReaderInterface = {\r\n  /**\r\n   * The unique serial number is primary identifier inner plugin.\r\n   */\r\n  serialNumber: string;\r\n\r\n  label: string;\r\n  batteryLevel: number;\r\n  batteryStatus: BatteryStatus;\r\n  simulated: boolean;\r\n  id: number;\r\n  availableUpdate: ReaderSoftwareUpdateInterface | undefined;\r\n  locationId: string;\r\n  ipAddress: string;\r\n  status: NetworkStatus;\r\n  location: LocationInterface | undefined;\r\n  locationStatus: LocationStatus;\r\n  deviceType: DeviceType;\r\n  deviceSoftwareVersion: string | null;\r\n\r\n  /**\r\n   * iOS Only properties. These properties are not available on Android.\r\n   */\r\n  isCharging: number;\r\n\r\n  /**\r\n   * Android Only properties. These properties are not available on iOS.\r\n   */\r\n  baseUrl: string;\r\n  bootloaderVersion: string;\r\n  configVersion: string;\r\n  emvKeyProfileId: string;\r\n  firmwareVersion: string;\r\n  hardwareVersion: string;\r\n  macKeyProfileId: string;\r\n  pinKeyProfileId: string;\r\n  trackKeyProfileId: string;\r\n  settingsVersion: string;\r\n  pinKeysetId: string;\r\n};\r\nexport type LocationInterface = {\r\n  id: string;\r\n  displayName: string;\r\n  address: {\r\n    city: string;\r\n    country: string;\r\n    postalCode: string;\r\n    line1: string;\r\n    line2: string;\r\n    state: string;\r\n  };\r\n  ipAddress: string;\r\n};\r\n\r\nexport type ReaderSoftwareUpdateInterface = {\r\n  deviceSoftwareVersion: string;\r\n  estimatedUpdateTime: UpdateTimeEstimate;\r\n  requiredAt: number;\r\n};\r\n\r\nexport type CartLineItem = {\r\n  displayName: string;\r\n  quantity: number;\r\n  amount: number;\r\n};\r\n\r\nexport type Cart = {\r\n  currency: string;\r\n  tax: number;\r\n  total: number;\r\n  lineItems: CartLineItem[];\r\n};\r\n\r\nexport * from './events.enum';\r\nexport * from './stripe.enum';\r\nexport interface StripeTerminalPlugin {\r\n  initialize(options: { tokenProviderEndpoint?: string; isTest: boolean }): Promise<void>;\r\n  discoverReaders(options: { type: TerminalConnectTypes; locationId?: string }): Promise<{\r\n    readers: ReaderInterface[];\r\n  }>;\r\n  setConnectionToken(options: { token: string }): Promise<void>;\r\n  /**\r\n   * [*Stripe docs reference*](https://stripe.dev/stripe-terminal-android/external/com.stripe.stripeterminal.external.models/-simulator-configuration/index.html)\r\n   */\r\n  setSimulatorConfiguration(options: {\r\n    update?: SimulateReaderUpdate;\r\n    simulatedCard?: SimulatedCardType;\r\n    simulatedTipAmount?: number;\r\n  }): Promise<void>;\r\n\r\n  /**\r\n   * @param options.autoReconnectOnUnexpectedDisconnect If true, the SDK will automatically attempt to reconnect to the reader. default is false.\r\n   */\r\n  connectReader(options: {\r\n    reader: ReaderInterface;\r\n    autoReconnectOnUnexpectedDisconnect?: boolean;\r\n\r\n    /**\r\n     * iOS and LocalMobileReader only. Android needs to be set to PaymentIntent only.\r\n     */\r\n    merchantDisplayName?: string;\r\n\r\n    /**\r\n     * iOS and LocalMobileReader only. Android needs to be set to PaymentIntent only.\r\n     * The Stripe account ID for which these funds are intended.\r\n     */\r\n    onBehalfOf?: string;\r\n  }): Promise<void>;\r\n  getConnectedReader(): Promise<{ reader: ReaderInterface | null }>;\r\n  disconnectReader(): Promise<void>;\r\n  cancelDiscoverReaders(): Promise<void>;\r\n  collectPaymentMethod(options: { paymentIntent: string }): Promise<void>;\r\n  cancelCollectPaymentMethod(): Promise<void>;\r\n  confirmPaymentIntent(): Promise<void>;\r\n  processPayment(options: { paymentIntentId: string }): Promise<{ status: string; id: string }>;\r\n  installAvailableUpdate(): Promise<void>;\r\n  cancelInstallUpdate(): Promise<void>;\r\n  setReaderDisplay(options: Cart): Promise<void>;\r\n  clearReaderDisplay(): Promise<void>;\r\n  rebootReader(): Promise<void>;\r\n  cancelReaderReconnection(): Promise<void>;\r\n\r\n  addListener(eventName: TerminalEventsEnum.Loaded, listenerFunc: () => void): Promise<PluginListenerHandle>;\r\n\r\n  addListener(\r\n    eventName: TerminalEventsEnum.RequestedConnectionToken,\r\n    listenerFunc: () => void,\r\n  ): Promise<PluginListenerHandle>;\r\n\r\n  addListener(\r\n    eventName: TerminalEventsEnum.DiscoveredReaders,\r\n    listenerFunc: ({ readers }: { readers: ReaderInterface[] }) => void,\r\n  ): Promise<PluginListenerHandle>;\r\n\r\n  addListener(eventName: TerminalEventsEnum.ConnectedReader, listenerFunc: () => void): Promise<PluginListenerHandle>;\r\n\r\n  /**\r\n   * Emitted when the reader is disconnected, either in response to [`disconnectReader()`](#disconnectreader)\r\n   * or some connection error.\r\n   *\r\n   * For all reader types, this is emitted in response to [`disconnectReader()`](#disconnectreader)\r\n   * without a `reason` property.\r\n   *\r\n   * For Bluetooth and USB readers, this is emitted with a `reason` property when the reader disconnects.\r\n   *\r\n   * **Note:** For Bluetooth and USB readers, when you call [`disconnectReader()`](#disconnectreader), this event\r\n   * will be emitted twice: one without a `reason` in acknowledgement of your call, and again with a `reason` when the reader\r\n   * finishes disconnecting.\r\n   */\r\n  addListener(\r\n    eventName: TerminalEventsEnum.DisconnectedReader,\r\n    listenerFunc: ({ reason }: { reason?: DisconnectReason }) => void,\r\n  ): Promise<PluginListenerHandle>;\r\n\r\n  /**\r\n   * Emitted when the Terminal's connection status changed.\r\n   *\r\n   * Note: You should *not* use this method to detect when a reader unexpectedly disconnects from your app,\r\n   * as it cannot be used to accurately distinguish between expected and unexpected disconnect events.\r\n   *\r\n   * To detect unexpected disconnects (e.g. to automatically notify your user), you should instead use\r\n   * the UnexpectedReaderDisconnect event.\r\n   *\r\n   * [*Stripe docs reference*](https://stripe.dev/stripe-terminal-android/external/com.stripe.stripeterminal.external.callable/-terminal-listener/on-connection-status-change.html)\r\n   */\r\n  addListener(\r\n    eventName: TerminalEventsEnum.ConnectionStatusChange,\r\n    listenerFunc: ({ status }: { status: ConnectionStatus }) => void,\r\n  ): Promise<PluginListenerHandle>;\r\n\r\n  /**\r\n   * The Terminal disconnected unexpectedly from the reader.\r\n   *\r\n   * In your implementation of this method, you may want to notify your user that the reader disconnected.\r\n   * You may also call [`discoverReaders()`](#discoverreaders) to begin scanning for readers, and attempt\r\n   * to automatically reconnect to the disconnected reader. Be sure to either set a timeout or make it\r\n   * possible to cancel calls to `discoverReaders()`\r\n   *\r\n   * When connected to a Bluetooth or USB reader, you can get more information about the disconnect by\r\n   * implementing the DisconnectedReader event.\r\n   *\r\n   * [*Stripe docs reference*](https://stripe.dev/stripe-terminal-android/external/com.stripe.stripeterminal.external.callable/-terminal-listener/on-unexpected-reader-disconnect.html)\r\n   */\r\n  addListener(\r\n    eventName: TerminalEventsEnum.UnexpectedReaderDisconnect,\r\n    listenerFunc: ({ reader }: { reader: ReaderInterface }) => void,\r\n  ): Promise<PluginListenerHandle>;\r\n\r\n  addListener(\r\n    eventName: TerminalEventsEnum.ConfirmedPaymentIntent,\r\n    listenerFunc: () => void,\r\n  ): Promise<PluginListenerHandle>;\r\n\r\n  addListener(\r\n    eventName: TerminalEventsEnum.CollectedPaymentIntent,\r\n    listenerFunc: () => void,\r\n  ): Promise<PluginListenerHandle>;\r\n\r\n  /**\r\n   * Emitted when [`cancelCollectPaymentMethod()`](#cancelcollectpaymentmethod) is called and succeeds.\r\n   * The Promise returned by `cancelCollectPaymentMethod()` will also be resolved.\r\n   */\r\n  addListener(eventName: TerminalEventsEnum.Canceled, listenerFunc: () => void): Promise<PluginListenerHandle>;\r\n\r\n  /**\r\n   * Emitted when either [`collectPaymentMethod()`](#collectpaymentmethod) or [`confirmPaymentIntent()`](#confirmpaymentintent)\r\n   * fails. The Promise returned by the relevant call will also be rejected.\r\n   */\r\n  addListener(\r\n    eventName: TerminalEventsEnum.Failed,\r\n    listenerFunc: (info: { message: string; code?: string; declineCode?: string }) => void,\r\n  ): Promise<PluginListenerHandle>;\r\n\r\n  /**\r\n   * Emitted when a software update is available for the connected reader.\r\n   */\r\n  addListener(\r\n    eventName: TerminalEventsEnum.ReportAvailableUpdate,\r\n    listenerFunc: ({ update }: { update: ReaderSoftwareUpdateInterface }) => void,\r\n  ): Promise<PluginListenerHandle>;\r\n\r\n  /**\r\n   * **Only applicable to Bluetooth and USB readers.**\r\n   *\r\n   * Emitted when the connected reader begins installing a software update.\r\n   * If a mandatory software update is available when a reader first connects, that update is\r\n   * automatically installed. The update will be installed before ConnectedReader is emitted and\r\n   * before the Promise returned by [`connectReader()`](#connectreader) resolves.\r\n   * In this case, you will receive this sequence of events:\r\n   *\r\n   * 1. StartInstallingUpdate\r\n   * 2. ReaderSoftwareUpdateProgress (repeatedly)\r\n   * 3. FinishInstallingUpdates\r\n   * 4. ConnectedReader\r\n   * 5. `connectReader()` Promise resolves\r\n   *\r\n   * Your app should show UI to the user indiciating that a software update is being installed\r\n   * to explain why connecting is taking longer than usual.\r\n   *\r\n   * [*Stripe docs reference*](https://stripe.dev/stripe-terminal-android/external/com.stripe.stripeterminal.external.callable/-reader-listener/on-start-installing-update.html)\r\n   */\r\n  addListener(\r\n    eventName: TerminalEventsEnum.StartInstallingUpdate,\r\n    listenerFunc: ({ update }: { update: ReaderSoftwareUpdateInterface }) => void,\r\n  ): Promise<PluginListenerHandle>;\r\n\r\n  /**\r\n   * **Only applicable to Bluetooth and USB readers.**\r\n   *\r\n   * Emitted periodically while reader software is updating to inform of the installation progress.\r\n   * `progress` is a float between 0 and 1.\r\n   *\r\n   * [*Stripe docs reference*](https://stripe.dev/stripe-terminal-android/external/com.stripe.stripeterminal.external.callable/-reader-listener/on-report-reader-software-update-progress.html)\r\n   */\r\n  addListener(\r\n    eventName: TerminalEventsEnum.ReaderSoftwareUpdateProgress,\r\n    listenerFunc: ({ progress }: { progress: number }) => void,\r\n  ): Promise<PluginListenerHandle>;\r\n\r\n  /**\r\n   * **Only applicable to Bluetooth and USB readers.**\r\n   *\r\n   * [*Stripe docs reference*](https://stripe.dev/stripe-terminal-android/external/com.stripe.stripeterminal.external.callable/-reader-listener/on-finish-installing-update.html)\r\n   */\r\n  addListener(\r\n    eventName: TerminalEventsEnum.FinishInstallingUpdate,\r\n    listenerFunc: (\r\n      args:\r\n        | {\r\n            update: ReaderSoftwareUpdateInterface;\r\n          }\r\n        | {\r\n            error: string;\r\n          },\r\n    ) => void,\r\n  ): Promise<PluginListenerHandle>;\r\n\r\n  /**\r\n   * **Only applicable to Bluetooth and USB readers.**\r\n   *\r\n   * Emitted upon connection and every 10 minutes.\r\n   *\r\n   * [*Stripe docs reference*](https://stripe.dev/stripe-terminal-android/external/com.stripe.stripeterminal.external.callable/-reader-listener/on-battery-level-update.html)\r\n   */\r\n  addListener(\r\n    eventName: TerminalEventsEnum.BatteryLevel,\r\n    listenerFunc: ({ level, charging, status }: { level: number; charging: boolean; status: BatteryStatus }) => void,\r\n  ): Promise<PluginListenerHandle>;\r\n\r\n  /**\r\n   * **Only applicable to Bluetooth and USB readers.**\r\n   *\r\n   * [*Stripe docs reference*](https://stripe.dev/stripe-terminal-android/external/com.stripe.stripeterminal.external.callable/-reader-listenable/on-report-reader-event.html)\r\n   */\r\n  addListener(\r\n    eventName: TerminalEventsEnum.ReaderEvent,\r\n    listenerFunc: ({ event }: { event: ReaderEvent }) => void,\r\n  ): Promise<PluginListenerHandle>;\r\n\r\n  /**\r\n   * **Only applicable to Bluetooth and USB readers.**\r\n   *\r\n   * Emitted when the Terminal requests that a message be displayed in your app.\r\n   *\r\n   * [*Stripe docs reference*](https://stripe.dev/stripe-terminal-android/external/com.stripe.stripeterminal.external.callable/-reader-listener/on-request-reader-display-message.html)\r\n   */\r\n  addListener(\r\n    eventName: TerminalEventsEnum.RequestDisplayMessage,\r\n    listenerFunc: ({ messageType, message }: { messageType: ReaderDisplayMessage; message: string }) => void,\r\n  ): Promise<PluginListenerHandle>;\r\n\r\n  /**\r\n   * **Only applicable to Bluetooth and USB readers.**\r\n   *\r\n   * Emitted when the reader begins waiting for input. Your app should prompt the customer\r\n   * to present a source using one of the given input options. If the reader emits a message,\r\n   * the RequestDisplayMessage event will be emitted.\r\n   *\r\n   * [*Stripe docs reference*](https://stripe.dev/stripe-terminal-android/external/com.stripe.stripeterminal.external.callable/-reader-listener/on-request-reader-input.html)\r\n   */\r\n  addListener(\r\n    eventName: TerminalEventsEnum.RequestReaderInput,\r\n    listenerFunc: ({ options, message }: { options: ReaderInputOption[]; message: string }) => void,\r\n  ): Promise<PluginListenerHandle>;\r\n\r\n  /**\r\n   * [*Stripe docs reference*](https://stripe.dev/stripe-terminal-android/external/com.stripe.stripeterminal.external.callable/-terminal-listener/on-payment-status-change.html)\r\n   */\r\n  addListener(\r\n    eventName: TerminalEventsEnum.PaymentStatusChange,\r\n    listenerFunc: ({ status }: { status: PaymentStatus }) => void,\r\n  ): Promise<PluginListenerHandle>;\r\n\r\n  addListener(\r\n    eventName: TerminalEventsEnum.ReaderReconnectStarted,\r\n    listenerFunc: ({ reader, reason }: { reader: ReaderInterface; reason: string }) => void,\r\n  ): Promise<PluginListenerHandle>;\r\n\r\n  addListener(\r\n    eventName: TerminalEventsEnum.ReaderReconnectSucceeded,\r\n    listenerFunc: ({ reader }: { reader: ReaderInterface }) => void,\r\n  ): Promise<PluginListenerHandle>;\r\n\r\n  addListener(\r\n    eventName: TerminalEventsEnum.ReaderReconnectFailed,\r\n    listenerFunc: ({ reader }: { reader: ReaderInterface }) => void,\r\n  ): Promise<PluginListenerHandle>;\r\n\r\n  addListener(\r\n    eventName: TerminalEventsEnum.ProcessedPayment,\r\n    listenerFunc: ({ id }: { id: string }) => void,\r\n  ): Promise<PluginListenerHandle>;\r\n}\r\n"]}